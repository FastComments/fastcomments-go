/*
fastcomments

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


// PublicAPIService PublicAPI service
type PublicAPIService service

type ApiBlockFromCommentPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	commentId string
	publicBlockFromCommentParams *PublicBlockFromCommentParams
	sso *string
}

func (r ApiBlockFromCommentPublicRequest) TenantId(tenantId string) ApiBlockFromCommentPublicRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiBlockFromCommentPublicRequest) PublicBlockFromCommentParams(publicBlockFromCommentParams PublicBlockFromCommentParams) ApiBlockFromCommentPublicRequest {
	r.publicBlockFromCommentParams = &publicBlockFromCommentParams
	return r
}

func (r ApiBlockFromCommentPublicRequest) Sso(sso string) ApiBlockFromCommentPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiBlockFromCommentPublicRequest) Execute() (*BlockFromCommentPublic200Response, *http.Response, error) {
	return r.ApiService.BlockFromCommentPublicExecute(r)
}

/*
BlockFromCommentPublic Method for BlockFromCommentPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId
 @return ApiBlockFromCommentPublicRequest
*/
func (a *PublicAPIService) BlockFromCommentPublic(ctx context.Context, commentId string) ApiBlockFromCommentPublicRequest {
	return ApiBlockFromCommentPublicRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return BlockFromCommentPublic200Response
func (a *PublicAPIService) BlockFromCommentPublicExecute(r ApiBlockFromCommentPublicRequest) (*BlockFromCommentPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockFromCommentPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.BlockFromCommentPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-from-comment/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}
	if r.publicBlockFromCommentParams == nil {
		return localVarReturnValue, nil, reportError("publicBlockFromCommentParams is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicBlockFromCommentParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckedCommentsForBlockedRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	commentIds *string
	sso *string
}

func (r ApiCheckedCommentsForBlockedRequest) TenantId(tenantId string) ApiCheckedCommentsForBlockedRequest {
	r.tenantId = &tenantId
	return r
}

// A comma separated list of comment ids.
func (r ApiCheckedCommentsForBlockedRequest) CommentIds(commentIds string) ApiCheckedCommentsForBlockedRequest {
	r.commentIds = &commentIds
	return r
}

func (r ApiCheckedCommentsForBlockedRequest) Sso(sso string) ApiCheckedCommentsForBlockedRequest {
	r.sso = &sso
	return r
}

func (r ApiCheckedCommentsForBlockedRequest) Execute() (*CheckedCommentsForBlocked200Response, *http.Response, error) {
	return r.ApiService.CheckedCommentsForBlockedExecute(r)
}

/*
CheckedCommentsForBlocked Method for CheckedCommentsForBlocked

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckedCommentsForBlockedRequest
*/
func (a *PublicAPIService) CheckedCommentsForBlocked(ctx context.Context) ApiCheckedCommentsForBlockedRequest {
	return ApiCheckedCommentsForBlockedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckedCommentsForBlocked200Response
func (a *PublicAPIService) CheckedCommentsForBlockedExecute(r ApiCheckedCommentsForBlockedRequest) (*CheckedCommentsForBlocked200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedCommentsForBlocked200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CheckedCommentsForBlocked")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/check-blocked-comments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}
	if r.commentIds == nil {
		return localVarReturnValue, nil, reportError("commentIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "commentIds", r.commentIds, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCommentPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	urlId *string
	broadcastId *string
	commentData *CommentData
	sessionId *string
	sso *string
}

func (r ApiCreateCommentPublicRequest) UrlId(urlId string) ApiCreateCommentPublicRequest {
	r.urlId = &urlId
	return r
}

func (r ApiCreateCommentPublicRequest) BroadcastId(broadcastId string) ApiCreateCommentPublicRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiCreateCommentPublicRequest) CommentData(commentData CommentData) ApiCreateCommentPublicRequest {
	r.commentData = &commentData
	return r
}

func (r ApiCreateCommentPublicRequest) SessionId(sessionId string) ApiCreateCommentPublicRequest {
	r.sessionId = &sessionId
	return r
}

func (r ApiCreateCommentPublicRequest) Sso(sso string) ApiCreateCommentPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiCreateCommentPublicRequest) Execute() (*CreateCommentPublic200Response, *http.Response, error) {
	return r.ApiService.CreateCommentPublicExecute(r)
}

/*
CreateCommentPublic Method for CreateCommentPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiCreateCommentPublicRequest
*/
func (a *PublicAPIService) CreateCommentPublic(ctx context.Context, tenantId string) ApiCreateCommentPublicRequest {
	return ApiCreateCommentPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return CreateCommentPublic200Response
func (a *PublicAPIService) CreateCommentPublicExecute(r ApiCreateCommentPublicRequest) (*CreateCommentPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCommentPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CreateCommentPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}
	if r.commentData == nil {
		return localVarReturnValue, nil, reportError("commentData is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.sessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionId", r.sessionId, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.commentData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFeedPostPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	createFeedPostParams *CreateFeedPostParams
	broadcastId *string
	sso *string
}

func (r ApiCreateFeedPostPublicRequest) CreateFeedPostParams(createFeedPostParams CreateFeedPostParams) ApiCreateFeedPostPublicRequest {
	r.createFeedPostParams = &createFeedPostParams
	return r
}

func (r ApiCreateFeedPostPublicRequest) BroadcastId(broadcastId string) ApiCreateFeedPostPublicRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiCreateFeedPostPublicRequest) Sso(sso string) ApiCreateFeedPostPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiCreateFeedPostPublicRequest) Execute() (*CreateFeedPostPublic200Response, *http.Response, error) {
	return r.ApiService.CreateFeedPostPublicExecute(r)
}

/*
CreateFeedPostPublic Method for CreateFeedPostPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiCreateFeedPostPublicRequest
*/
func (a *PublicAPIService) CreateFeedPostPublic(ctx context.Context, tenantId string) ApiCreateFeedPostPublicRequest {
	return ApiCreateFeedPostPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return CreateFeedPostPublic200Response
func (a *PublicAPIService) CreateFeedPostPublicExecute(r ApiCreateFeedPostPublicRequest) (*CreateFeedPostPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFeedPostPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CreateFeedPostPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed-posts/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFeedPostParams == nil {
		return localVarReturnValue, nil, reportError("createFeedPostParams is required and must be specified")
	}

	if r.broadcastId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFeedPostParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCommentPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	broadcastId *string
	editKey *string
	sso *string
}

func (r ApiDeleteCommentPublicRequest) BroadcastId(broadcastId string) ApiDeleteCommentPublicRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiDeleteCommentPublicRequest) EditKey(editKey string) ApiDeleteCommentPublicRequest {
	r.editKey = &editKey
	return r
}

func (r ApiDeleteCommentPublicRequest) Sso(sso string) ApiDeleteCommentPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiDeleteCommentPublicRequest) Execute() (*DeleteCommentPublic200Response, *http.Response, error) {
	return r.ApiService.DeleteCommentPublicExecute(r)
}

/*
DeleteCommentPublic Method for DeleteCommentPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiDeleteCommentPublicRequest
*/
func (a *PublicAPIService) DeleteCommentPublic(ctx context.Context, tenantId string, commentId string) ApiDeleteCommentPublicRequest {
	return ApiDeleteCommentPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return DeleteCommentPublic200Response
func (a *PublicAPIService) DeleteCommentPublicExecute(r ApiDeleteCommentPublicRequest) (*DeleteCommentPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteCommentPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.DeleteCommentPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.editKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "editKey", r.editKey, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCommentVoteRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	voteId string
	urlId *string
	broadcastId *string
	editKey *string
	sso *string
}

func (r ApiDeleteCommentVoteRequest) UrlId(urlId string) ApiDeleteCommentVoteRequest {
	r.urlId = &urlId
	return r
}

func (r ApiDeleteCommentVoteRequest) BroadcastId(broadcastId string) ApiDeleteCommentVoteRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiDeleteCommentVoteRequest) EditKey(editKey string) ApiDeleteCommentVoteRequest {
	r.editKey = &editKey
	return r
}

func (r ApiDeleteCommentVoteRequest) Sso(sso string) ApiDeleteCommentVoteRequest {
	r.sso = &sso
	return r
}

func (r ApiDeleteCommentVoteRequest) Execute() (*DeleteCommentVote200Response, *http.Response, error) {
	return r.ApiService.DeleteCommentVoteExecute(r)
}

/*
DeleteCommentVote Method for DeleteCommentVote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @param voteId
 @return ApiDeleteCommentVoteRequest
*/
func (a *PublicAPIService) DeleteCommentVote(ctx context.Context, tenantId string, commentId string, voteId string) ApiDeleteCommentVoteRequest {
	return ApiDeleteCommentVoteRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
		voteId: voteId,
	}
}

// Execute executes the request
//  @return DeleteCommentVote200Response
func (a *PublicAPIService) DeleteCommentVoteExecute(r ApiDeleteCommentVoteRequest) (*DeleteCommentVote200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteCommentVote200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.DeleteCommentVote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/vote/{voteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voteId"+"}", url.PathEscape(parameterValueToString(r.voteId, "voteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.editKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "editKey", r.editKey, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFeedPostPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	postId string
	broadcastId *string
	sso *string
}

func (r ApiDeleteFeedPostPublicRequest) BroadcastId(broadcastId string) ApiDeleteFeedPostPublicRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiDeleteFeedPostPublicRequest) Sso(sso string) ApiDeleteFeedPostPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiDeleteFeedPostPublicRequest) Execute() (*DeleteFeedPostPublic200Response, *http.Response, error) {
	return r.ApiService.DeleteFeedPostPublicExecute(r)
}

/*
DeleteFeedPostPublic Method for DeleteFeedPostPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param postId
 @return ApiDeleteFeedPostPublicRequest
*/
func (a *PublicAPIService) DeleteFeedPostPublic(ctx context.Context, tenantId string, postId string) ApiDeleteFeedPostPublicRequest {
	return ApiDeleteFeedPostPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		postId: postId,
	}
}

// Execute executes the request
//  @return DeleteFeedPostPublic200Response
func (a *PublicAPIService) DeleteFeedPostPublicExecute(r ApiDeleteFeedPostPublicRequest) (*DeleteFeedPostPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteFeedPostPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.DeleteFeedPostPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed-posts/{tenantId}/{postId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"postId"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.broadcastId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlagCommentPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	commentId string
	isFlagged *bool
	sso *string
}

func (r ApiFlagCommentPublicRequest) TenantId(tenantId string) ApiFlagCommentPublicRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiFlagCommentPublicRequest) IsFlagged(isFlagged bool) ApiFlagCommentPublicRequest {
	r.isFlagged = &isFlagged
	return r
}

func (r ApiFlagCommentPublicRequest) Sso(sso string) ApiFlagCommentPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiFlagCommentPublicRequest) Execute() (*FlagCommentPublic200Response, *http.Response, error) {
	return r.ApiService.FlagCommentPublicExecute(r)
}

/*
FlagCommentPublic Method for FlagCommentPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId
 @return ApiFlagCommentPublicRequest
*/
func (a *PublicAPIService) FlagCommentPublic(ctx context.Context, commentId string) ApiFlagCommentPublicRequest {
	return ApiFlagCommentPublicRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return FlagCommentPublic200Response
func (a *PublicAPIService) FlagCommentPublicExecute(r ApiFlagCommentPublicRequest) (*FlagCommentPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlagCommentPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.FlagCommentPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flag-comment/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}
	if r.isFlagged == nil {
		return localVarReturnValue, nil, reportError("isFlagged is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "isFlagged", r.isFlagged, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentTextRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	editKey *string
	sso *string
}

func (r ApiGetCommentTextRequest) EditKey(editKey string) ApiGetCommentTextRequest {
	r.editKey = &editKey
	return r
}

func (r ApiGetCommentTextRequest) Sso(sso string) ApiGetCommentTextRequest {
	r.sso = &sso
	return r
}

func (r ApiGetCommentTextRequest) Execute() (*GetCommentText200Response, *http.Response, error) {
	return r.ApiService.GetCommentTextExecute(r)
}

/*
GetCommentText Method for GetCommentText

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiGetCommentTextRequest
*/
func (a *PublicAPIService) GetCommentText(ctx context.Context, tenantId string, commentId string) ApiGetCommentTextRequest {
	return ApiGetCommentTextRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return GetCommentText200Response
func (a *PublicAPIService) GetCommentTextExecute(r ApiGetCommentTextRequest) (*GetCommentText200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCommentText200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetCommentText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/text"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.editKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "editKey", r.editKey, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentVoteUserNamesRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	dir *int32
	sso *string
}

func (r ApiGetCommentVoteUserNamesRequest) Dir(dir int32) ApiGetCommentVoteUserNamesRequest {
	r.dir = &dir
	return r
}

func (r ApiGetCommentVoteUserNamesRequest) Sso(sso string) ApiGetCommentVoteUserNamesRequest {
	r.sso = &sso
	return r
}

func (r ApiGetCommentVoteUserNamesRequest) Execute() (*GetCommentVoteUserNames200Response, *http.Response, error) {
	return r.ApiService.GetCommentVoteUserNamesExecute(r)
}

/*
GetCommentVoteUserNames Method for GetCommentVoteUserNames

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiGetCommentVoteUserNamesRequest
*/
func (a *PublicAPIService) GetCommentVoteUserNames(ctx context.Context, tenantId string, commentId string) ApiGetCommentVoteUserNamesRequest {
	return ApiGetCommentVoteUserNamesRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return GetCommentVoteUserNames200Response
func (a *PublicAPIService) GetCommentVoteUserNamesExecute(r ApiGetCommentVoteUserNamesRequest) (*GetCommentVoteUserNames200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCommentVoteUserNames200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetCommentVoteUserNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/votes"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dir == nil {
		return localVarReturnValue, nil, reportError("dir is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dir", r.dir, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentsPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	urlId *string
	page *int32
	direction *SortDirections
	sso *string
	skip *int32
	skipChildren *int32
	limit *int32
	limitChildren *int32
	countChildren *bool
	fetchPageForCommentId *string
	includeConfig *bool
	countAll *bool
	includei10n *bool
	locale *string
	modules *string
	isCrawler *bool
	includeNotificationCount *bool
	asTree *bool
	maxTreeDepth *int32
	useFullTranslationIds *bool
	parentId *string
	searchText *string
	hashTags *[]string
	userId *string
	customConfigStr *string
	afterCommentId *string
	beforeCommentId *string
}

func (r ApiGetCommentsPublicRequest) UrlId(urlId string) ApiGetCommentsPublicRequest {
	r.urlId = &urlId
	return r
}

func (r ApiGetCommentsPublicRequest) Page(page int32) ApiGetCommentsPublicRequest {
	r.page = &page
	return r
}

func (r ApiGetCommentsPublicRequest) Direction(direction SortDirections) ApiGetCommentsPublicRequest {
	r.direction = &direction
	return r
}

func (r ApiGetCommentsPublicRequest) Sso(sso string) ApiGetCommentsPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiGetCommentsPublicRequest) Skip(skip int32) ApiGetCommentsPublicRequest {
	r.skip = &skip
	return r
}

func (r ApiGetCommentsPublicRequest) SkipChildren(skipChildren int32) ApiGetCommentsPublicRequest {
	r.skipChildren = &skipChildren
	return r
}

func (r ApiGetCommentsPublicRequest) Limit(limit int32) ApiGetCommentsPublicRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCommentsPublicRequest) LimitChildren(limitChildren int32) ApiGetCommentsPublicRequest {
	r.limitChildren = &limitChildren
	return r
}

func (r ApiGetCommentsPublicRequest) CountChildren(countChildren bool) ApiGetCommentsPublicRequest {
	r.countChildren = &countChildren
	return r
}

func (r ApiGetCommentsPublicRequest) FetchPageForCommentId(fetchPageForCommentId string) ApiGetCommentsPublicRequest {
	r.fetchPageForCommentId = &fetchPageForCommentId
	return r
}

func (r ApiGetCommentsPublicRequest) IncludeConfig(includeConfig bool) ApiGetCommentsPublicRequest {
	r.includeConfig = &includeConfig
	return r
}

func (r ApiGetCommentsPublicRequest) CountAll(countAll bool) ApiGetCommentsPublicRequest {
	r.countAll = &countAll
	return r
}

func (r ApiGetCommentsPublicRequest) Includei10n(includei10n bool) ApiGetCommentsPublicRequest {
	r.includei10n = &includei10n
	return r
}

func (r ApiGetCommentsPublicRequest) Locale(locale string) ApiGetCommentsPublicRequest {
	r.locale = &locale
	return r
}

func (r ApiGetCommentsPublicRequest) Modules(modules string) ApiGetCommentsPublicRequest {
	r.modules = &modules
	return r
}

func (r ApiGetCommentsPublicRequest) IsCrawler(isCrawler bool) ApiGetCommentsPublicRequest {
	r.isCrawler = &isCrawler
	return r
}

func (r ApiGetCommentsPublicRequest) IncludeNotificationCount(includeNotificationCount bool) ApiGetCommentsPublicRequest {
	r.includeNotificationCount = &includeNotificationCount
	return r
}

func (r ApiGetCommentsPublicRequest) AsTree(asTree bool) ApiGetCommentsPublicRequest {
	r.asTree = &asTree
	return r
}

func (r ApiGetCommentsPublicRequest) MaxTreeDepth(maxTreeDepth int32) ApiGetCommentsPublicRequest {
	r.maxTreeDepth = &maxTreeDepth
	return r
}

func (r ApiGetCommentsPublicRequest) UseFullTranslationIds(useFullTranslationIds bool) ApiGetCommentsPublicRequest {
	r.useFullTranslationIds = &useFullTranslationIds
	return r
}

func (r ApiGetCommentsPublicRequest) ParentId(parentId string) ApiGetCommentsPublicRequest {
	r.parentId = &parentId
	return r
}

func (r ApiGetCommentsPublicRequest) SearchText(searchText string) ApiGetCommentsPublicRequest {
	r.searchText = &searchText
	return r
}

func (r ApiGetCommentsPublicRequest) HashTags(hashTags []string) ApiGetCommentsPublicRequest {
	r.hashTags = &hashTags
	return r
}

func (r ApiGetCommentsPublicRequest) UserId(userId string) ApiGetCommentsPublicRequest {
	r.userId = &userId
	return r
}

func (r ApiGetCommentsPublicRequest) CustomConfigStr(customConfigStr string) ApiGetCommentsPublicRequest {
	r.customConfigStr = &customConfigStr
	return r
}

func (r ApiGetCommentsPublicRequest) AfterCommentId(afterCommentId string) ApiGetCommentsPublicRequest {
	r.afterCommentId = &afterCommentId
	return r
}

func (r ApiGetCommentsPublicRequest) BeforeCommentId(beforeCommentId string) ApiGetCommentsPublicRequest {
	r.beforeCommentId = &beforeCommentId
	return r
}

func (r ApiGetCommentsPublicRequest) Execute() (*GetCommentsPublic200Response, *http.Response, error) {
	return r.ApiService.GetCommentsPublicExecute(r)
}

/*
GetCommentsPublic Method for GetCommentsPublic


req
tenantId
urlId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiGetCommentsPublicRequest
*/
func (a *PublicAPIService) GetCommentsPublic(ctx context.Context, tenantId string) ApiGetCommentsPublicRequest {
	return ApiGetCommentsPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return GetCommentsPublic200Response
func (a *PublicAPIService) GetCommentsPublicExecute(r ApiGetCommentsPublicRequest) (*GetCommentsPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCommentsPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetCommentsPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	}
	if r.skipChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipChildren", r.skipChildren, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.limitChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limitChildren", r.limitChildren, "form", "")
	}
	if r.countChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countChildren", r.countChildren, "form", "")
	}
	if r.fetchPageForCommentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchPageForCommentId", r.fetchPageForCommentId, "form", "")
	}
	if r.includeConfig != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeConfig", r.includeConfig, "form", "")
	}
	if r.countAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countAll", r.countAll, "form", "")
	}
	if r.includei10n != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includei10n", r.includei10n, "form", "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "form", "")
	}
	if r.modules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modules", r.modules, "form", "")
	}
	if r.isCrawler != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isCrawler", r.isCrawler, "form", "")
	}
	if r.includeNotificationCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNotificationCount", r.includeNotificationCount, "form", "")
	}
	if r.asTree != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asTree", r.asTree, "form", "")
	}
	if r.maxTreeDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxTreeDepth", r.maxTreeDepth, "form", "")
	}
	if r.useFullTranslationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useFullTranslationIds", r.useFullTranslationIds, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "form", "")
	}
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "form", "")
	}
	if r.hashTags != nil {
		t := *r.hashTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashTags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashTags", t, "form", "multi")
		}
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.customConfigStr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customConfigStr", r.customConfigStr, "form", "")
	}
	if r.afterCommentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterCommentId", r.afterCommentId, "form", "")
	}
	if r.beforeCommentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beforeCommentId", r.beforeCommentId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventLogRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	urlId *string
	userIdWS *string
	startTime *int64
	endTime *int64
}

func (r ApiGetEventLogRequest) UrlId(urlId string) ApiGetEventLogRequest {
	r.urlId = &urlId
	return r
}

func (r ApiGetEventLogRequest) UserIdWS(userIdWS string) ApiGetEventLogRequest {
	r.userIdWS = &userIdWS
	return r
}

func (r ApiGetEventLogRequest) StartTime(startTime int64) ApiGetEventLogRequest {
	r.startTime = &startTime
	return r
}

func (r ApiGetEventLogRequest) EndTime(endTime int64) ApiGetEventLogRequest {
	r.endTime = &endTime
	return r
}

func (r ApiGetEventLogRequest) Execute() (*GetEventLog200Response, *http.Response, error) {
	return r.ApiService.GetEventLogExecute(r)
}

/*
GetEventLog Method for GetEventLog


req
tenantId
urlId
userIdWS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiGetEventLogRequest
*/
func (a *PublicAPIService) GetEventLog(ctx context.Context, tenantId string) ApiGetEventLogRequest {
	return ApiGetEventLogRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return GetEventLog200Response
func (a *PublicAPIService) GetEventLogExecute(r ApiGetEventLogRequest) (*GetEventLog200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEventLog200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetEventLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-log/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}
	if r.userIdWS == nil {
		return localVarReturnValue, nil, reportError("userIdWS is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userIdWS", r.userIdWS, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeedPostsPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	afterId *string
	limit *int32
	tags *[]string
	sso *string
	isCrawler *bool
	includeUserInfo *bool
}

func (r ApiGetFeedPostsPublicRequest) AfterId(afterId string) ApiGetFeedPostsPublicRequest {
	r.afterId = &afterId
	return r
}

func (r ApiGetFeedPostsPublicRequest) Limit(limit int32) ApiGetFeedPostsPublicRequest {
	r.limit = &limit
	return r
}

func (r ApiGetFeedPostsPublicRequest) Tags(tags []string) ApiGetFeedPostsPublicRequest {
	r.tags = &tags
	return r
}

func (r ApiGetFeedPostsPublicRequest) Sso(sso string) ApiGetFeedPostsPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiGetFeedPostsPublicRequest) IsCrawler(isCrawler bool) ApiGetFeedPostsPublicRequest {
	r.isCrawler = &isCrawler
	return r
}

func (r ApiGetFeedPostsPublicRequest) IncludeUserInfo(includeUserInfo bool) ApiGetFeedPostsPublicRequest {
	r.includeUserInfo = &includeUserInfo
	return r
}

func (r ApiGetFeedPostsPublicRequest) Execute() (*GetFeedPostsPublic200Response, *http.Response, error) {
	return r.ApiService.GetFeedPostsPublicExecute(r)
}

/*
GetFeedPostsPublic Method for GetFeedPostsPublic


req
tenantId
afterId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiGetFeedPostsPublicRequest
*/
func (a *PublicAPIService) GetFeedPostsPublic(ctx context.Context, tenantId string) ApiGetFeedPostsPublicRequest {
	return ApiGetFeedPostsPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return GetFeedPostsPublic200Response
func (a *PublicAPIService) GetFeedPostsPublicExecute(r ApiGetFeedPostsPublicRequest) (*GetFeedPostsPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFeedPostsPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetFeedPostsPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed-posts/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.afterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterId", r.afterId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	if r.isCrawler != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isCrawler", r.isCrawler, "form", "")
	}
	if r.includeUserInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUserInfo", r.includeUserInfo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeedPostsStatsRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	postIds *[]string
	sso *string
}

func (r ApiGetFeedPostsStatsRequest) PostIds(postIds []string) ApiGetFeedPostsStatsRequest {
	r.postIds = &postIds
	return r
}

func (r ApiGetFeedPostsStatsRequest) Sso(sso string) ApiGetFeedPostsStatsRequest {
	r.sso = &sso
	return r
}

func (r ApiGetFeedPostsStatsRequest) Execute() (*GetFeedPostsStats200Response, *http.Response, error) {
	return r.ApiService.GetFeedPostsStatsExecute(r)
}

/*
GetFeedPostsStats Method for GetFeedPostsStats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiGetFeedPostsStatsRequest
*/
func (a *PublicAPIService) GetFeedPostsStats(ctx context.Context, tenantId string) ApiGetFeedPostsStatsRequest {
	return ApiGetFeedPostsStatsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return GetFeedPostsStats200Response
func (a *PublicAPIService) GetFeedPostsStatsExecute(r ApiGetFeedPostsStatsRequest) (*GetFeedPostsStats200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFeedPostsStats200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetFeedPostsStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed-posts/{tenantId}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postIds == nil {
		return localVarReturnValue, nil, reportError("postIds is required and must be specified")
	}

	{
		t := *r.postIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postIds", t, "form", "multi")
		}
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalEventLogRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	urlId *string
	userIdWS *string
	startTime *int64
	endTime *int64
}

func (r ApiGetGlobalEventLogRequest) UrlId(urlId string) ApiGetGlobalEventLogRequest {
	r.urlId = &urlId
	return r
}

func (r ApiGetGlobalEventLogRequest) UserIdWS(userIdWS string) ApiGetGlobalEventLogRequest {
	r.userIdWS = &userIdWS
	return r
}

func (r ApiGetGlobalEventLogRequest) StartTime(startTime int64) ApiGetGlobalEventLogRequest {
	r.startTime = &startTime
	return r
}

func (r ApiGetGlobalEventLogRequest) EndTime(endTime int64) ApiGetGlobalEventLogRequest {
	r.endTime = &endTime
	return r
}

func (r ApiGetGlobalEventLogRequest) Execute() (*GetEventLog200Response, *http.Response, error) {
	return r.ApiService.GetGlobalEventLogExecute(r)
}

/*
GetGlobalEventLog Method for GetGlobalEventLog


req
tenantId
urlId
userIdWS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiGetGlobalEventLogRequest
*/
func (a *PublicAPIService) GetGlobalEventLog(ctx context.Context, tenantId string) ApiGetGlobalEventLogRequest {
	return ApiGetGlobalEventLogRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return GetEventLog200Response
func (a *PublicAPIService) GetGlobalEventLogExecute(r ApiGetGlobalEventLogRequest) (*GetEventLog200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEventLog200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetGlobalEventLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event-log/global/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}
	if r.userIdWS == nil {
		return localVarReturnValue, nil, reportError("userIdWS is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userIdWS", r.userIdWS, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserNotificationCountRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	sso *string
}

func (r ApiGetUserNotificationCountRequest) TenantId(tenantId string) ApiGetUserNotificationCountRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiGetUserNotificationCountRequest) Sso(sso string) ApiGetUserNotificationCountRequest {
	r.sso = &sso
	return r
}

func (r ApiGetUserNotificationCountRequest) Execute() (*GetUserNotificationCount200Response, *http.Response, error) {
	return r.ApiService.GetUserNotificationCountExecute(r)
}

/*
GetUserNotificationCount Method for GetUserNotificationCount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserNotificationCountRequest
*/
func (a *PublicAPIService) GetUserNotificationCount(ctx context.Context) ApiGetUserNotificationCountRequest {
	return ApiGetUserNotificationCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserNotificationCount200Response
func (a *PublicAPIService) GetUserNotificationCountExecute(r ApiGetUserNotificationCountRequest) (*GetUserNotificationCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserNotificationCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetUserNotificationCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-notifications/get-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserNotificationsRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	pageSize *int32
	afterId *string
	includeContext *bool
	afterCreatedAt *int64
	unreadOnly *bool
	dmOnly *bool
	noDm *bool
	includeTranslations *bool
	sso *string
}

func (r ApiGetUserNotificationsRequest) TenantId(tenantId string) ApiGetUserNotificationsRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiGetUserNotificationsRequest) PageSize(pageSize int32) ApiGetUserNotificationsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetUserNotificationsRequest) AfterId(afterId string) ApiGetUserNotificationsRequest {
	r.afterId = &afterId
	return r
}

func (r ApiGetUserNotificationsRequest) IncludeContext(includeContext bool) ApiGetUserNotificationsRequest {
	r.includeContext = &includeContext
	return r
}

func (r ApiGetUserNotificationsRequest) AfterCreatedAt(afterCreatedAt int64) ApiGetUserNotificationsRequest {
	r.afterCreatedAt = &afterCreatedAt
	return r
}

func (r ApiGetUserNotificationsRequest) UnreadOnly(unreadOnly bool) ApiGetUserNotificationsRequest {
	r.unreadOnly = &unreadOnly
	return r
}

func (r ApiGetUserNotificationsRequest) DmOnly(dmOnly bool) ApiGetUserNotificationsRequest {
	r.dmOnly = &dmOnly
	return r
}

func (r ApiGetUserNotificationsRequest) NoDm(noDm bool) ApiGetUserNotificationsRequest {
	r.noDm = &noDm
	return r
}

func (r ApiGetUserNotificationsRequest) IncludeTranslations(includeTranslations bool) ApiGetUserNotificationsRequest {
	r.includeTranslations = &includeTranslations
	return r
}

func (r ApiGetUserNotificationsRequest) Sso(sso string) ApiGetUserNotificationsRequest {
	r.sso = &sso
	return r
}

func (r ApiGetUserNotificationsRequest) Execute() (*GetUserNotifications200Response, *http.Response, error) {
	return r.ApiService.GetUserNotificationsExecute(r)
}

/*
GetUserNotifications Method for GetUserNotifications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserNotificationsRequest
*/
func (a *PublicAPIService) GetUserNotifications(ctx context.Context) ApiGetUserNotificationsRequest {
	return ApiGetUserNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserNotifications200Response
func (a *PublicAPIService) GetUserNotificationsExecute(r ApiGetUserNotificationsRequest) (*GetUserNotifications200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserNotifications200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetUserNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-notifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.afterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterId", r.afterId, "form", "")
	}
	if r.includeContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeContext", r.includeContext, "form", "")
	}
	if r.afterCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterCreatedAt", r.afterCreatedAt, "form", "")
	}
	if r.unreadOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unreadOnly", r.unreadOnly, "form", "")
	}
	if r.dmOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dmOnly", r.dmOnly, "form", "")
	}
	if r.noDm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noDm", r.noDm, "form", "")
	}
	if r.includeTranslations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTranslations", r.includeTranslations, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserPresenceStatusesRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	urlIdWS *string
	userIds *string
}

func (r ApiGetUserPresenceStatusesRequest) TenantId(tenantId string) ApiGetUserPresenceStatusesRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiGetUserPresenceStatusesRequest) UrlIdWS(urlIdWS string) ApiGetUserPresenceStatusesRequest {
	r.urlIdWS = &urlIdWS
	return r
}

func (r ApiGetUserPresenceStatusesRequest) UserIds(userIds string) ApiGetUserPresenceStatusesRequest {
	r.userIds = &userIds
	return r
}

func (r ApiGetUserPresenceStatusesRequest) Execute() (*GetUserPresenceStatuses200Response, *http.Response, error) {
	return r.ApiService.GetUserPresenceStatusesExecute(r)
}

/*
GetUserPresenceStatuses Method for GetUserPresenceStatuses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserPresenceStatusesRequest
*/
func (a *PublicAPIService) GetUserPresenceStatuses(ctx context.Context) ApiGetUserPresenceStatusesRequest {
	return ApiGetUserPresenceStatusesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserPresenceStatuses200Response
func (a *PublicAPIService) GetUserPresenceStatusesExecute(r ApiGetUserPresenceStatusesRequest) (*GetUserPresenceStatuses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserPresenceStatuses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetUserPresenceStatuses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-presence-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}
	if r.urlIdWS == nil {
		return localVarReturnValue, nil, reportError("urlIdWS is required and must be specified")
	}
	if r.userIds == nil {
		return localVarReturnValue, nil, reportError("userIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "urlIdWS", r.urlIdWS, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userIds", r.userIds, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserReactsPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	postIds *[]string
	sso *string
}

func (r ApiGetUserReactsPublicRequest) PostIds(postIds []string) ApiGetUserReactsPublicRequest {
	r.postIds = &postIds
	return r
}

func (r ApiGetUserReactsPublicRequest) Sso(sso string) ApiGetUserReactsPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiGetUserReactsPublicRequest) Execute() (*GetUserReactsPublic200Response, *http.Response, error) {
	return r.ApiService.GetUserReactsPublicExecute(r)
}

/*
GetUserReactsPublic Method for GetUserReactsPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiGetUserReactsPublicRequest
*/
func (a *PublicAPIService) GetUserReactsPublic(ctx context.Context, tenantId string) ApiGetUserReactsPublicRequest {
	return ApiGetUserReactsPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return GetUserReactsPublic200Response
func (a *PublicAPIService) GetUserReactsPublicExecute(r ApiGetUserReactsPublicRequest) (*GetUserReactsPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserReactsPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GetUserReactsPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed-posts/{tenantId}/user-reacts"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.postIds != nil {
		t := *r.postIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postIds", t, "form", "multi")
		}
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockCommentRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	broadcastId *string
	sso *string
}

func (r ApiLockCommentRequest) BroadcastId(broadcastId string) ApiLockCommentRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiLockCommentRequest) Sso(sso string) ApiLockCommentRequest {
	r.sso = &sso
	return r
}

func (r ApiLockCommentRequest) Execute() (*LockComment200Response, *http.Response, error) {
	return r.ApiService.LockCommentExecute(r)
}

/*
LockComment Method for LockComment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiLockCommentRequest
*/
func (a *PublicAPIService) LockComment(ctx context.Context, tenantId string, commentId string) ApiLockCommentRequest {
	return ApiLockCommentRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return LockComment200Response
func (a *PublicAPIService) LockCommentExecute(r ApiLockCommentRequest) (*LockComment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LockComment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.LockComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPinCommentRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	broadcastId *string
	sso *string
}

func (r ApiPinCommentRequest) BroadcastId(broadcastId string) ApiPinCommentRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiPinCommentRequest) Sso(sso string) ApiPinCommentRequest {
	r.sso = &sso
	return r
}

func (r ApiPinCommentRequest) Execute() (*PinComment200Response, *http.Response, error) {
	return r.ApiService.PinCommentExecute(r)
}

/*
PinComment Method for PinComment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiPinCommentRequest
*/
func (a *PublicAPIService) PinComment(ctx context.Context, tenantId string, commentId string) ApiPinCommentRequest {
	return ApiPinCommentRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return PinComment200Response
func (a *PublicAPIService) PinCommentExecute(r ApiPinCommentRequest) (*PinComment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PinComment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.PinComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/pin"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactFeedPostPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	postId string
	reactBodyParams *ReactBodyParams
	isUndo *bool
	broadcastId *string
	sso *string
}

func (r ApiReactFeedPostPublicRequest) ReactBodyParams(reactBodyParams ReactBodyParams) ApiReactFeedPostPublicRequest {
	r.reactBodyParams = &reactBodyParams
	return r
}

func (r ApiReactFeedPostPublicRequest) IsUndo(isUndo bool) ApiReactFeedPostPublicRequest {
	r.isUndo = &isUndo
	return r
}

func (r ApiReactFeedPostPublicRequest) BroadcastId(broadcastId string) ApiReactFeedPostPublicRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiReactFeedPostPublicRequest) Sso(sso string) ApiReactFeedPostPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiReactFeedPostPublicRequest) Execute() (*ReactFeedPostPublic200Response, *http.Response, error) {
	return r.ApiService.ReactFeedPostPublicExecute(r)
}

/*
ReactFeedPostPublic Method for ReactFeedPostPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param postId
 @return ApiReactFeedPostPublicRequest
*/
func (a *PublicAPIService) ReactFeedPostPublic(ctx context.Context, tenantId string, postId string) ApiReactFeedPostPublicRequest {
	return ApiReactFeedPostPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		postId: postId,
	}
}

// Execute executes the request
//  @return ReactFeedPostPublic200Response
func (a *PublicAPIService) ReactFeedPostPublicExecute(r ApiReactFeedPostPublicRequest) (*ReactFeedPostPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReactFeedPostPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.ReactFeedPostPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed-posts/{tenantId}/react/{postId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"postId"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactBodyParams == nil {
		return localVarReturnValue, nil, reportError("reactBodyParams is required and must be specified")
	}

	if r.isUndo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isUndo", r.isUndo, "form", "")
	}
	if r.broadcastId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetUserNotificationCountRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	sso *string
}

func (r ApiResetUserNotificationCountRequest) TenantId(tenantId string) ApiResetUserNotificationCountRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiResetUserNotificationCountRequest) Sso(sso string) ApiResetUserNotificationCountRequest {
	r.sso = &sso
	return r
}

func (r ApiResetUserNotificationCountRequest) Execute() (*ResetUserNotifications200Response, *http.Response, error) {
	return r.ApiService.ResetUserNotificationCountExecute(r)
}

/*
ResetUserNotificationCount Method for ResetUserNotificationCount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetUserNotificationCountRequest
*/
func (a *PublicAPIService) ResetUserNotificationCount(ctx context.Context) ApiResetUserNotificationCountRequest {
	return ApiResetUserNotificationCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResetUserNotifications200Response
func (a *PublicAPIService) ResetUserNotificationCountExecute(r ApiResetUserNotificationCountRequest) (*ResetUserNotifications200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResetUserNotifications200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.ResetUserNotificationCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-notifications/reset-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetUserNotificationsRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	afterId *string
	afterCreatedAt *int64
	unreadOnly *bool
	dmOnly *bool
	noDm *bool
	sso *string
}

func (r ApiResetUserNotificationsRequest) TenantId(tenantId string) ApiResetUserNotificationsRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiResetUserNotificationsRequest) AfterId(afterId string) ApiResetUserNotificationsRequest {
	r.afterId = &afterId
	return r
}

func (r ApiResetUserNotificationsRequest) AfterCreatedAt(afterCreatedAt int64) ApiResetUserNotificationsRequest {
	r.afterCreatedAt = &afterCreatedAt
	return r
}

func (r ApiResetUserNotificationsRequest) UnreadOnly(unreadOnly bool) ApiResetUserNotificationsRequest {
	r.unreadOnly = &unreadOnly
	return r
}

func (r ApiResetUserNotificationsRequest) DmOnly(dmOnly bool) ApiResetUserNotificationsRequest {
	r.dmOnly = &dmOnly
	return r
}

func (r ApiResetUserNotificationsRequest) NoDm(noDm bool) ApiResetUserNotificationsRequest {
	r.noDm = &noDm
	return r
}

func (r ApiResetUserNotificationsRequest) Sso(sso string) ApiResetUserNotificationsRequest {
	r.sso = &sso
	return r
}

func (r ApiResetUserNotificationsRequest) Execute() (*ResetUserNotifications200Response, *http.Response, error) {
	return r.ApiService.ResetUserNotificationsExecute(r)
}

/*
ResetUserNotifications Method for ResetUserNotifications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetUserNotificationsRequest
*/
func (a *PublicAPIService) ResetUserNotifications(ctx context.Context) ApiResetUserNotificationsRequest {
	return ApiResetUserNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResetUserNotifications200Response
func (a *PublicAPIService) ResetUserNotificationsExecute(r ApiResetUserNotificationsRequest) (*ResetUserNotifications200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResetUserNotifications200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.ResetUserNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-notifications/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.afterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterId", r.afterId, "form", "")
	}
	if r.afterCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterCreatedAt", r.afterCreatedAt, "form", "")
	}
	if r.unreadOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unreadOnly", r.unreadOnly, "form", "")
	}
	if r.dmOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dmOnly", r.dmOnly, "form", "")
	}
	if r.noDm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noDm", r.noDm, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchUsersRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	urlId *string
	usernameStartsWith *string
	mentionGroupIds *[]string
	sso *string
}

func (r ApiSearchUsersRequest) UrlId(urlId string) ApiSearchUsersRequest {
	r.urlId = &urlId
	return r
}

func (r ApiSearchUsersRequest) UsernameStartsWith(usernameStartsWith string) ApiSearchUsersRequest {
	r.usernameStartsWith = &usernameStartsWith
	return r
}

func (r ApiSearchUsersRequest) MentionGroupIds(mentionGroupIds []string) ApiSearchUsersRequest {
	r.mentionGroupIds = &mentionGroupIds
	return r
}

func (r ApiSearchUsersRequest) Sso(sso string) ApiSearchUsersRequest {
	r.sso = &sso
	return r
}

func (r ApiSearchUsersRequest) Execute() (*SearchUsers200Response, *http.Response, error) {
	return r.ApiService.SearchUsersExecute(r)
}

/*
SearchUsers Method for SearchUsers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiSearchUsersRequest
*/
func (a *PublicAPIService) SearchUsers(ctx context.Context, tenantId string) ApiSearchUsersRequest {
	return ApiSearchUsersRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return SearchUsers200Response
func (a *PublicAPIService) SearchUsersExecute(r ApiSearchUsersRequest) (*SearchUsers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchUsers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.SearchUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-search/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}
	if r.usernameStartsWith == nil {
		return localVarReturnValue, nil, reportError("usernameStartsWith is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "usernameStartsWith", r.usernameStartsWith, "form", "")
	if r.mentionGroupIds != nil {
		t := *r.mentionGroupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mentionGroupIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mentionGroupIds", t, "form", "multi")
		}
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetCommentTextRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	broadcastId *string
	commentTextUpdateRequest *CommentTextUpdateRequest
	editKey *string
	sso *string
}

func (r ApiSetCommentTextRequest) BroadcastId(broadcastId string) ApiSetCommentTextRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiSetCommentTextRequest) CommentTextUpdateRequest(commentTextUpdateRequest CommentTextUpdateRequest) ApiSetCommentTextRequest {
	r.commentTextUpdateRequest = &commentTextUpdateRequest
	return r
}

func (r ApiSetCommentTextRequest) EditKey(editKey string) ApiSetCommentTextRequest {
	r.editKey = &editKey
	return r
}

func (r ApiSetCommentTextRequest) Sso(sso string) ApiSetCommentTextRequest {
	r.sso = &sso
	return r
}

func (r ApiSetCommentTextRequest) Execute() (*SetCommentText200Response, *http.Response, error) {
	return r.ApiService.SetCommentTextExecute(r)
}

/*
SetCommentText Method for SetCommentText

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiSetCommentTextRequest
*/
func (a *PublicAPIService) SetCommentText(ctx context.Context, tenantId string, commentId string) ApiSetCommentTextRequest {
	return ApiSetCommentTextRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return SetCommentText200Response
func (a *PublicAPIService) SetCommentTextExecute(r ApiSetCommentTextRequest) (*SetCommentText200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetCommentText200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.SetCommentText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/update-text"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}
	if r.commentTextUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("commentTextUpdateRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.editKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "editKey", r.editKey, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.commentTextUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnBlockCommentPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	commentId string
	publicBlockFromCommentParams *PublicBlockFromCommentParams
	sso *string
}

func (r ApiUnBlockCommentPublicRequest) TenantId(tenantId string) ApiUnBlockCommentPublicRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiUnBlockCommentPublicRequest) PublicBlockFromCommentParams(publicBlockFromCommentParams PublicBlockFromCommentParams) ApiUnBlockCommentPublicRequest {
	r.publicBlockFromCommentParams = &publicBlockFromCommentParams
	return r
}

func (r ApiUnBlockCommentPublicRequest) Sso(sso string) ApiUnBlockCommentPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiUnBlockCommentPublicRequest) Execute() (*UnBlockCommentPublic200Response, *http.Response, error) {
	return r.ApiService.UnBlockCommentPublicExecute(r)
}

/*
UnBlockCommentPublic Method for UnBlockCommentPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param commentId
 @return ApiUnBlockCommentPublicRequest
*/
func (a *PublicAPIService) UnBlockCommentPublic(ctx context.Context, commentId string) ApiUnBlockCommentPublicRequest {
	return ApiUnBlockCommentPublicRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return UnBlockCommentPublic200Response
func (a *PublicAPIService) UnBlockCommentPublicExecute(r ApiUnBlockCommentPublicRequest) (*UnBlockCommentPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnBlockCommentPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UnBlockCommentPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-from-comment/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}
	if r.publicBlockFromCommentParams == nil {
		return localVarReturnValue, nil, reportError("publicBlockFromCommentParams is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicBlockFromCommentParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnLockCommentRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	broadcastId *string
	sso *string
}

func (r ApiUnLockCommentRequest) BroadcastId(broadcastId string) ApiUnLockCommentRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiUnLockCommentRequest) Sso(sso string) ApiUnLockCommentRequest {
	r.sso = &sso
	return r
}

func (r ApiUnLockCommentRequest) Execute() (*LockComment200Response, *http.Response, error) {
	return r.ApiService.UnLockCommentExecute(r)
}

/*
UnLockComment Method for UnLockComment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiUnLockCommentRequest
*/
func (a *PublicAPIService) UnLockComment(ctx context.Context, tenantId string, commentId string) ApiUnLockCommentRequest {
	return ApiUnLockCommentRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return LockComment200Response
func (a *PublicAPIService) UnLockCommentExecute(r ApiUnLockCommentRequest) (*LockComment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LockComment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UnLockComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/unlock"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnPinCommentRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	broadcastId *string
	sso *string
}

func (r ApiUnPinCommentRequest) BroadcastId(broadcastId string) ApiUnPinCommentRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiUnPinCommentRequest) Sso(sso string) ApiUnPinCommentRequest {
	r.sso = &sso
	return r
}

func (r ApiUnPinCommentRequest) Execute() (*PinComment200Response, *http.Response, error) {
	return r.ApiService.UnPinCommentExecute(r)
}

/*
UnPinComment Method for UnPinComment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiUnPinCommentRequest
*/
func (a *PublicAPIService) UnPinComment(ctx context.Context, tenantId string, commentId string) ApiUnPinCommentRequest {
	return ApiUnPinCommentRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return PinComment200Response
func (a *PublicAPIService) UnPinCommentExecute(r ApiUnPinCommentRequest) (*PinComment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PinComment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UnPinComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/unpin"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFeedPostPublicRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	postId string
	updateFeedPostParams *UpdateFeedPostParams
	broadcastId *string
	sso *string
}

func (r ApiUpdateFeedPostPublicRequest) UpdateFeedPostParams(updateFeedPostParams UpdateFeedPostParams) ApiUpdateFeedPostPublicRequest {
	r.updateFeedPostParams = &updateFeedPostParams
	return r
}

func (r ApiUpdateFeedPostPublicRequest) BroadcastId(broadcastId string) ApiUpdateFeedPostPublicRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiUpdateFeedPostPublicRequest) Sso(sso string) ApiUpdateFeedPostPublicRequest {
	r.sso = &sso
	return r
}

func (r ApiUpdateFeedPostPublicRequest) Execute() (*CreateFeedPostPublic200Response, *http.Response, error) {
	return r.ApiService.UpdateFeedPostPublicExecute(r)
}

/*
UpdateFeedPostPublic Method for UpdateFeedPostPublic

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param postId
 @return ApiUpdateFeedPostPublicRequest
*/
func (a *PublicAPIService) UpdateFeedPostPublic(ctx context.Context, tenantId string, postId string) ApiUpdateFeedPostPublicRequest {
	return ApiUpdateFeedPostPublicRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		postId: postId,
	}
}

// Execute executes the request
//  @return CreateFeedPostPublic200Response
func (a *PublicAPIService) UpdateFeedPostPublicExecute(r ApiUpdateFeedPostPublicRequest) (*CreateFeedPostPublic200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFeedPostPublic200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UpdateFeedPostPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed-posts/{tenantId}/{postId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"postId"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFeedPostParams == nil {
		return localVarReturnValue, nil, reportError("updateFeedPostParams is required and must be specified")
	}

	if r.broadcastId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFeedPostParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserNotificationCommentSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	notificationId string
	optedInOrOut string
	commentId *string
	sso *string
}

func (r ApiUpdateUserNotificationCommentSubscriptionStatusRequest) TenantId(tenantId string) ApiUpdateUserNotificationCommentSubscriptionStatusRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiUpdateUserNotificationCommentSubscriptionStatusRequest) CommentId(commentId string) ApiUpdateUserNotificationCommentSubscriptionStatusRequest {
	r.commentId = &commentId
	return r
}

func (r ApiUpdateUserNotificationCommentSubscriptionStatusRequest) Sso(sso string) ApiUpdateUserNotificationCommentSubscriptionStatusRequest {
	r.sso = &sso
	return r
}

func (r ApiUpdateUserNotificationCommentSubscriptionStatusRequest) Execute() (*UpdateUserNotificationStatus200Response, *http.Response, error) {
	return r.ApiService.UpdateUserNotificationCommentSubscriptionStatusExecute(r)
}

/*
UpdateUserNotificationCommentSubscriptionStatus Method for UpdateUserNotificationCommentSubscriptionStatus

Enable or disable notifications for a specific comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notificationId
 @param optedInOrOut
 @return ApiUpdateUserNotificationCommentSubscriptionStatusRequest
*/
func (a *PublicAPIService) UpdateUserNotificationCommentSubscriptionStatus(ctx context.Context, notificationId string, optedInOrOut string) ApiUpdateUserNotificationCommentSubscriptionStatusRequest {
	return ApiUpdateUserNotificationCommentSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		notificationId: notificationId,
		optedInOrOut: optedInOrOut,
	}
}

// Execute executes the request
//  @return UpdateUserNotificationStatus200Response
func (a *PublicAPIService) UpdateUserNotificationCommentSubscriptionStatusExecute(r ApiUpdateUserNotificationCommentSubscriptionStatusRequest) (*UpdateUserNotificationStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateUserNotificationStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UpdateUserNotificationCommentSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-notifications/{notificationId}/mark-opted/{optedInOrOut}"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationId"+"}", url.PathEscape(parameterValueToString(r.notificationId, "notificationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"optedInOrOut"+"}", url.PathEscape(parameterValueToString(r.optedInOrOut, "optedInOrOut")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}
	if r.commentId == nil {
		return localVarReturnValue, nil, reportError("commentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "commentId", r.commentId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserNotificationPageSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	urlId *string
	url *string
	pageTitle *string
	subscribedOrUnsubscribed string
	sso *string
}

func (r ApiUpdateUserNotificationPageSubscriptionStatusRequest) TenantId(tenantId string) ApiUpdateUserNotificationPageSubscriptionStatusRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiUpdateUserNotificationPageSubscriptionStatusRequest) UrlId(urlId string) ApiUpdateUserNotificationPageSubscriptionStatusRequest {
	r.urlId = &urlId
	return r
}

func (r ApiUpdateUserNotificationPageSubscriptionStatusRequest) Url(url string) ApiUpdateUserNotificationPageSubscriptionStatusRequest {
	r.url = &url
	return r
}

func (r ApiUpdateUserNotificationPageSubscriptionStatusRequest) PageTitle(pageTitle string) ApiUpdateUserNotificationPageSubscriptionStatusRequest {
	r.pageTitle = &pageTitle
	return r
}

func (r ApiUpdateUserNotificationPageSubscriptionStatusRequest) Sso(sso string) ApiUpdateUserNotificationPageSubscriptionStatusRequest {
	r.sso = &sso
	return r
}

func (r ApiUpdateUserNotificationPageSubscriptionStatusRequest) Execute() (*UpdateUserNotificationStatus200Response, *http.Response, error) {
	return r.ApiService.UpdateUserNotificationPageSubscriptionStatusExecute(r)
}

/*
UpdateUserNotificationPageSubscriptionStatus Method for UpdateUserNotificationPageSubscriptionStatus

Enable or disable notifications for a page. When users are subscribed to a page, notifications are created
for new root comments, and also

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscribedOrUnsubscribed
 @return ApiUpdateUserNotificationPageSubscriptionStatusRequest
*/
func (a *PublicAPIService) UpdateUserNotificationPageSubscriptionStatus(ctx context.Context, subscribedOrUnsubscribed string) ApiUpdateUserNotificationPageSubscriptionStatusRequest {
	return ApiUpdateUserNotificationPageSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		subscribedOrUnsubscribed: subscribedOrUnsubscribed,
	}
}

// Execute executes the request
//  @return UpdateUserNotificationStatus200Response
func (a *PublicAPIService) UpdateUserNotificationPageSubscriptionStatusExecute(r ApiUpdateUserNotificationPageSubscriptionStatusRequest) (*UpdateUserNotificationStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateUserNotificationStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UpdateUserNotificationPageSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-notifications/set-subscription-state/{subscribedOrUnsubscribed}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscribedOrUnsubscribed"+"}", url.PathEscape(parameterValueToString(r.subscribedOrUnsubscribed, "subscribedOrUnsubscribed")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}
	if r.pageTitle == nil {
		return localVarReturnValue, nil, reportError("pageTitle is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pageTitle", r.pageTitle, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserNotificationStatusRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId *string
	notificationId string
	newStatus string
	sso *string
}

func (r ApiUpdateUserNotificationStatusRequest) TenantId(tenantId string) ApiUpdateUserNotificationStatusRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiUpdateUserNotificationStatusRequest) Sso(sso string) ApiUpdateUserNotificationStatusRequest {
	r.sso = &sso
	return r
}

func (r ApiUpdateUserNotificationStatusRequest) Execute() (*UpdateUserNotificationStatus200Response, *http.Response, error) {
	return r.ApiService.UpdateUserNotificationStatusExecute(r)
}

/*
UpdateUserNotificationStatus Method for UpdateUserNotificationStatus

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notificationId
 @param newStatus
 @return ApiUpdateUserNotificationStatusRequest
*/
func (a *PublicAPIService) UpdateUserNotificationStatus(ctx context.Context, notificationId string, newStatus string) ApiUpdateUserNotificationStatusRequest {
	return ApiUpdateUserNotificationStatusRequest{
		ApiService: a,
		ctx: ctx,
		notificationId: notificationId,
		newStatus: newStatus,
	}
}

// Execute executes the request
//  @return UpdateUserNotificationStatus200Response
func (a *PublicAPIService) UpdateUserNotificationStatusExecute(r ApiUpdateUserNotificationStatusRequest) (*UpdateUserNotificationStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateUserNotificationStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UpdateUserNotificationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user-notifications/{notificationId}/mark/{newStatus}"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationId"+"}", url.PathEscape(parameterValueToString(r.notificationId, "notificationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"newStatus"+"}", url.PathEscape(parameterValueToString(r.newStatus, "newStatus")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadImageRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	file *os.File
	sizePreset *SizePreset
	urlId *string
}

func (r ApiUploadImageRequest) File(file *os.File) ApiUploadImageRequest {
	r.file = file
	return r
}

// Size preset: \&quot;Default\&quot; (1000x1000px) or \&quot;CrossPlatform\&quot; (creates sizes for popular devices)
func (r ApiUploadImageRequest) SizePreset(sizePreset SizePreset) ApiUploadImageRequest {
	r.sizePreset = &sizePreset
	return r
}

// Page id that upload is happening from, to configure
func (r ApiUploadImageRequest) UrlId(urlId string) ApiUploadImageRequest {
	r.urlId = &urlId
	return r
}

func (r ApiUploadImageRequest) Execute() (*UploadImageResponse, *http.Response, error) {
	return r.ApiService.UploadImageExecute(r)
}

/*
UploadImage Method for UploadImage

Upload and resize an image

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiUploadImageRequest
*/
func (a *PublicAPIService) UploadImage(ctx context.Context, tenantId string) ApiUploadImageRequest {
	return ApiUploadImageRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return UploadImageResponse
func (a *PublicAPIService) UploadImageExecute(r ApiUploadImageRequest) (*UploadImageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadImageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UploadImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upload-image/{tenantId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	if r.sizePreset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sizePreset", r.sizePreset, "form", "")
	}
	if r.urlId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVoteCommentRequest struct {
	ctx context.Context
	ApiService *PublicAPIService
	tenantId string
	commentId string
	urlId *string
	broadcastId *string
	voteBodyParams *VoteBodyParams
	sessionId *string
	sso *string
}

func (r ApiVoteCommentRequest) UrlId(urlId string) ApiVoteCommentRequest {
	r.urlId = &urlId
	return r
}

func (r ApiVoteCommentRequest) BroadcastId(broadcastId string) ApiVoteCommentRequest {
	r.broadcastId = &broadcastId
	return r
}

func (r ApiVoteCommentRequest) VoteBodyParams(voteBodyParams VoteBodyParams) ApiVoteCommentRequest {
	r.voteBodyParams = &voteBodyParams
	return r
}

func (r ApiVoteCommentRequest) SessionId(sessionId string) ApiVoteCommentRequest {
	r.sessionId = &sessionId
	return r
}

func (r ApiVoteCommentRequest) Sso(sso string) ApiVoteCommentRequest {
	r.sso = &sso
	return r
}

func (r ApiVoteCommentRequest) Execute() (*VoteComment200Response, *http.Response, error) {
	return r.ApiService.VoteCommentExecute(r)
}

/*
VoteComment Method for VoteComment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param commentId
 @return ApiVoteCommentRequest
*/
func (a *PublicAPIService) VoteComment(ctx context.Context, tenantId string, commentId string) ApiVoteCommentRequest {
	return ApiVoteCommentRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return VoteComment200Response
func (a *PublicAPIService) VoteCommentExecute(r ApiVoteCommentRequest) (*VoteComment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VoteComment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.VoteComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{tenantId}/{commentId}/vote"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.urlId == nil {
		return localVarReturnValue, nil, reportError("urlId is required and must be specified")
	}
	if r.broadcastId == nil {
		return localVarReturnValue, nil, reportError("broadcastId is required and must be specified")
	}
	if r.voteBodyParams == nil {
		return localVarReturnValue, nil, reportError("voteBodyParams is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "urlId", r.urlId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "broadcastId", r.broadcastId, "form", "")
	if r.sessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionId", r.sessionId, "form", "")
	}
	if r.sso != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sso", r.sso, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.voteBodyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
